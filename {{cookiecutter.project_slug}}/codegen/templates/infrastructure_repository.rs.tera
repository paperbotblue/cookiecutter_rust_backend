use uuid::Uuid;
use sqlx::{query, query_as, PgPool};
use async_trait::async_trait;
use crate::domain::models::{{type_snake}}::{Create{{type_name}}, {{type_name}}, Update{{type_name}}};
use crate::domain::repositories::{{type_snake}}::{{type_name}}QueryParams;
use crate::domain::repositories::{{type_snake}}::{{type_name}}Repository;
use base::result_paging::{
    QueryParams, RepositoryResult, ResultPaging
};

pub struct {{type_name}}DieselRepository {
    pub pool: PgPool,
}

impl {{type_name}}DieselRepository {
    pub fn new(db: PgPool) -> Self {
        {{type_name}}DieselRepository { pool: db }
    }
}

#[async_trait]
impl {{type_name}}Repository for {{type_name}}DieselRepository {
async fn create(&self, new_item: &Create{{ type_name }}) -> RepositoryResult<{{ type_name }}> {
    Ok(
        query_as!(
            {{ type_name }},
            r#"
                INSERT INTO {{ type_snake }}s
                (
                    id,
                    {%- for item in create_type_fields %}
                    {{ item.field }},
                    {%- endfor %}
                )
                VALUES
                (
                    $1,
                    {%- for item in create_type_fields %}
                    ${{ loop.index + 1 }},
                    {%- endfor %}
                )
                RETURNING *
            "#,
            Uuid::new_v4(),
            {%- for item in create_type_fields %}
            new_item.{{ item.field }},
            {%- endfor %}
        )
        .fetch_one(&self.pool)
        .await?
    )
}


async fn update(&self, new_item: &Update{{ type_name }}) -> RepositoryResult<{{ type_name }}> {
    Ok(
        query_as!(
            {{ type_name }},
            r#"
                UPDATE {{ type_snake }}s
                SET
                    {%- for item in create_type_fields %}
                    {{ item.field }} = ${{ loop.index + 1 }},
                    {%- endfor %}
                WHERE
                    id = $1
                RETURNING *
            "#,
            new_item.id,
            {%- for item in create_type_fields %}
            new_item.{{ item.field }},
            {%- endfor %}
        )
        .fetch_one(&self.pool)
        .await?
    )
}

    async fn list(&self, params: {{type_name}}QueryParams) -> RepositoryResult<ResultPaging<{{type_name}}>> {
        let result = query_as!(
            {{ type_name }},
            r#"
                SELECT * FROM {{ type_snake }}s LIMIT $1 OFFSET $2
            "#,
            params.limit(),
            params.offset()
        )
        .fetch_all(&self.pool)
        .await?;

        let total = query!(
            r#"
            SELECT COUNT(*) as "count!"
            FROM {{ type_snake }}s
        "#
        )
        .fetch_one(&self.pool)
        .await?
        .count;

        Ok(ResultPaging {
            total,
            items: result,
        })
    }

    async fn get(&self, item_id: Uuid) -> RepositoryResult<Option<{{type_name}}>> {
      Ok(
        query_as!(
          {{ type_name }},
          r#"
              SELECT * FROM {{ type_snake }}s
              WHERE
              id = $1
          "#,
          item_id
        ).fetch_optional(&self.pool).await?
        )
    }

    async fn delete(&self, item_id: Uuid) -> RepositoryResult<()> {
        query!(
          r#"
              DELETE FROM {{ type_snake }}s
              WHERE
              id = $1
          "#,
          item_id
        ).execute(&self.pool).await?;
      Ok(())
    }
}

